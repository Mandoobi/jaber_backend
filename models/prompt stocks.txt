Ok perfect but we now want to do something else how can i track the quantity of products i want if a sales add a sample to the report before sumbitign it check if it really have the amount that he want to give i don't want him to send sampels that he don't have stock of it so how could we do it? if he add to the report and sumbit it is remove the quantity from the same product stokc if he for example cancle it or delete (he or the admin admin can also edit the report sample) it should go back to the stock for the (sales) and the most important i want to have history with it i done all of those but i want to finsh them And also make includeInAnalysis: false; bcz we track how much he get from the start of month so only in reports thing we should use includeInAnalysis false so don't worry about it so let's go how can we done this? Dailyreport controller.js const validateSamples = async (samples, companyId) => {
  const validationResults = await Promise.all(samples.map(async (s, index) => {
    const errors = [];
    
    // Basic validation
    if (!s.productId || !mongoose.Types.ObjectId.isValid(s.productId)) {
      errors.push('Invalid product ID');
    }
    if (!s.quantity || s.quantity <= 0) {
      errors.push('Quantity must be greater than 0');
    }
    if (!['customer', 'personal'].includes(s.type)) {
      errors.push('Invalid sample type');
    }

    // Validate product exists and belongs to company
    if (s.productId && mongoose.Types.ObjectId.isValid(s.productId)) {
      const product = await Product.findOne({
        _id: s.productId,
        companyId
      });
      if (!product) {
        errors.push('Product not found or not in company');
      }
    }

    // Additional validation for customer samples
    if (s.type === 'customer') {
      if (!s.customerId || !mongoose.Types.ObjectId.isValid(s.customerId)) {
        errors.push('Invalid customer ID');
      } else {
        // Validate customer exists and belongs to company
        const customer = await Customer.findOne({
          _id: s.customerId,
          companyId
        });
        if (!customer) {
          errors.push('Customer not found or not in company');
        }
      }
    }

    return {
      sample: s,
      isValid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined
    };
  }));

  return {
    validSamples: validationResults.filter(r => r.isValid).map(r => r.sample),
    invalidSamples: validationResults.filter(r => !r.isValid)
  };
};

const handleSamples = async (samples, report, userId, companyId, deletedSampleIds = []) => {
  // First handle deletions
  if (deletedSampleIds && deletedSampleIds.length > 0) {
    await Sample.deleteMany({
      _id: { $in: deletedSampleIds },
      reportId: report._id,
      companyId
    });
    console.log(`Deleted ${deletedSampleIds.length} samples`);
  }

  if (!Array.isArray(samples) || !report._id) {
    return { samplesCount: 0 };
  }

  const { validSamples, invalidSamples } = await validateSamples(samples, companyId);

  if (invalidSamples.length > 0) {
    console.log('Sample validation errors:', invalidSamples);
  }

  if (validSamples.length > 0) {
    // Prepare samples data with visit linking
    const samplesToSave = validSamples.map(s => {
      const sampleData = {
        companyId,
        takenBy: userId,
        productId: s.productId,
        quantity: s.quantity,
        type: s.type,
        reportId: report._id,
        notes: s.notes || ''
      };

      // For existing samples, preserve the ID
      if (s._id) {
        sampleData._id = s._id;
      }

      // Add customerId and visitId for customer samples
      if (s.type === 'customer') {
        sampleData.customerId = s.customerId;
      }

      return sampleData;
    });

    // Use bulkWrite to handle both inserts and updates
    const bulkOps = samplesToSave.map(sample => ({
      updateOne: {
        filter: { _id: sample._id || new mongoose.Types.ObjectId() },
        update: { $set: sample },
        upsert: true
      }
    }));

    const result = await Sample.bulkWrite(bulkOps);
    console.log(`Processed ${result.upsertedCount + result.modifiedCount} samples`);
  }

  return {
    samplesCount: validSamples.length,
    invalidSamples: invalidSamples.length > 0 ? invalidSamples : undefined
  };
};

// Main controller
const createOrUpdateReport = async (req, res) => {
  try {
    const { role, userId, companyId, username } = req.user;

    // Ù†ØµÙˆØµ Ø­ØªÙƒÙˆÙ† ÙƒÙ€ string ÙÙŠ form-dataØŒ Ù„Ø§Ø²Ù… parse Ù„Ù„Ø­Ù‚Ù„ Ø§Ù„Ù…Ø¹Ù‚Ø¯
    const {
      notes,
      reportId,
      isAdminUpdate = 'false' // Ù„Ùˆ Ø­Ø¨ÙŠØª ØªØ³ØªØ®Ø¯Ù…Ù‡ Ù„Ø§Ø­Ù‚Ù‹Ø§
    } = req.body;

    // parse Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø©
    const visits = req.body.visits ? JSON.parse(req.body.visits) : [];
    const samples = req.body.samples ? JSON.parse(req.body.samples) : [];
    const deletedSamples = req.body.deletedSamples ? JSON.parse(req.body.deletedSamples) : [];

    // Ø®Ø° Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØµÙˆØ± Ø§Ù„Ù„ÙŠ ØªÙ… Ø±ÙØ¹Ù‡Ø§ (cloudinary paths)
    const images = req.files ? req.files.map(file => file.path) : [];

    // Ø§Ø·Ø¨Ø¹ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØµÙˆØ± ÙÙŠ Ø§Ù„ÙƒÙˆÙ†Ø³ÙˆÙ„
    if (images.length > 0) {
      console.log('Uploaded image URLs:');
      images.forEach(url => console.log(url));
    }

    // Validate visits
    const { isValid: visitsValid, cleanedVisits, error: visitsError } = validateVisits(visits);
    if (!visitsValid) {
      return sendError(res, 400, visitsError);
    }

    // Validate customers
    const customerIds = cleanedVisits.map(v => v.customerId);
    const customersError = await validateCustomers(customerIds, companyId);
    if (customersError) return sendError(res, 400, customersError);

    const currentDate = now();
    const dateStr = currentDate.format('YYYY-MM-DD');
    const day = currentDate.format('dddd');

    // SALES REP LOGIC
    if (role === 'sales') {
      let report = await DailyReport.findOne({
        repId: userId,
        companyId,
        date: dateStr
      });

      if (reportId && (!report || !report._id.equals(reportId))) {
        return sendError(res, 400, 'ğŸ“› ÙŠÙ…ÙƒÙ†Ùƒ ÙÙ‚Ø· ØªØ¹Ø¯ÙŠÙ„ ØªÙ‚Ø±ÙŠØ± Ø§Ù„ÙŠÙˆÙ… Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ');
      }

      const processedVisits = await processVisitsForSalesRep(cleanedVisits, userId, companyId, day);
      const stats = calculateVisitStats(processedVisits);

      if (report) {
        report.notes = notes || report.notes;
        report.visits = processedVisits;
        report.stats = stats;

        // Ø£Ø¶Ù Ø§Ù„ØµÙˆØ± Ù„Ù„Ù€ report.images (Ù…Ø«Ù„Ø§Ù‹ ØªØ¬Ù…Ø¹Ù‡Ø§ ÙƒÙ„Ù‡Ø§)
        report.images = [...(report.images || []), ...images];

        await report.save();
      } else {
        report = new DailyReport({
          companyId,
          repId: userId,
          date: dateStr,
          day,
          notes: notes || '',
          visits: processedVisits,
          stats,
          images
        });
        await report.save();
      }

      // Notification to admins
      const adminIds = await getAdmins(companyId, userId);

      await Notification.create({
        userId: userId,
        targetUsers: adminIds,
        actionType: reportId ? 'update_daily_report' : 'send_daily_report',
        description: reportId
          ? `Ù‚Ø§Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ${username} Ø¨ØªØ­Ø¯ÙŠØ« ØªÙ‚Ø±ÙŠØ±Ù‡ Ø§Ù„ÙŠÙˆÙ…ÙŠ.`
          : `Ù‚Ø§Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ${username} Ø¨Ø¥Ø±Ø³Ø§Ù„ ØªÙ‚Ø±ÙŠØ±Ù‡ Ø§Ù„ÙŠÙˆÙ…ÙŠ Ø¨Ù†Ø¬Ø§Ø­.`,
        relatedEntity: {
          entityType: 'DailyReport',
          entityId: report._id
        },
        data: {
          date: dateStr,
          repName: username,
          visitsCount: stats.totalVisits,
          completedVisits: stats.completedVisits
        }
      }).catch(err => console.error('Notification error:', err));

      // Handle samples
      const { samplesCount, invalidSamples } = await handleSamples(
        samples,
        report,
        userId,
        companyId,
        deletedSamples
      );

      return sendSuccess(
        res,
        reportId ? 200 : 201,
        reportId ? 'âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø¨Ù†Ø¬Ø§Ø­' : 'âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø¨Ù†Ø¬Ø§Ø­',
        {
          report,
          samplesCount,
          invalidSamples
        }
      );
    }

    // ADMIN LOGIC
    if (role === 'admin') {
      if (!reportId) return sendError(res, 400, 'ğŸ“› ÙŠØ¬Ø¨ ØªÙ‚Ø¯ÙŠÙ… Ù…Ø¹Ø±Ù Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ù„Ù„ØªØ­Ø¯ÙŠØ«');

      const report = await DailyReport.findOne({ _id: reportId, companyId });
      if (!report) return sendError(res, 404, 'âŒ Ø§Ù„ØªÙ‚Ø±ÙŠØ± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ø£Ùˆ Ù„Ø§ ÙŠÙ†ØªÙ…ÙŠ Ù„Ø´Ø±ÙƒØªÙƒ');

      const processedVisits = await processVisitsForSalesRep(cleanedVisits, report.repId, companyId, day);
      const stats = calculateVisitStats(processedVisits);

      report.notes = notes || report.notes;
      report.visits = processedVisits;
      report.stats = stats;

      // Ø£Ø¶Ù Ø§Ù„ØµÙˆØ± Ù„Ù„Ù€ report.images (Ù†Ø¬Ù…Ø¹ Ø§Ù„ØµÙˆØ± Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ù…Ø¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©)
      report.images = [...(report.images || []), ...images];

      await report.save();

      // Handle samples for admin
      const { samplesCount } = await handleSamples(samples, report, userId, companyId);

      return sendSuccess(res, 200, 'âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø¨Ù†Ø¬Ø§Ø­ Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ù…Ø¯ÙŠØ±', {
        report,
        samplesCount
      });
    }

    return sendError(res, 403, 'ğŸš« ØºÙŠØ± Ù…ØµØ±Ø­ Ù„Ùƒ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡');
  } catch (error) {
    console.error('âŒ Error in createOrUpdateReport:', error);
    return sendError(res, 500, 'âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù… Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠ');
  }
}; Product.js const mongoose = require('mongoose');

const productSchema = new mongoose.Schema(
  {
    name: { type: String, required: true, trim: true },
    description: { type: String, trim: true },
    companyId: { type: mongoose.Schema.Types.ObjectId, ref: 'Company', required: true },
    unitType: {
      type: String,
      enum: ['ÙƒØ±ØªÙˆÙ†Ø©', 'Ø¹Ù„Ø¨Ø©', 'Ø­Ø¨Ø©', 'Ø±Ø¨Ø·Ø©'],
      required: true
    },
    weight: { type: Number },
    weightUnit: {
      type: String,
      enum: ['ÙƒÙŠÙ„Ùˆ', 'Ø¬Ø±Ø§Ù…', 'Ù…Ù„ÙŠÙ„ØªØ±', 'Ù„ØªØ±'],
      required: function () {
        return this.weight !== undefined;
      }
    },
    isActive: { type: Boolean, default: true }
  },
  { timestamps: true }
);

module.exports = mongoose.model('Product', productSchema);
 RepProductStock.js const { Schema, model, Types } = require('mongoose');

const repProductStockSchema = new Schema({
  companyId: {
    type: Types.ObjectId,
    ref: 'Company',
    required: true
  },
  repId: {
    type: Types.ObjectId,
    ref: 'User',
    required: true
  },
  productId: {
    type: Types.ObjectId,
    ref: 'Product',
    required: true
  },
  quantity: {
    type: Number,
    default: 0,
    min: 0
  }
}, {
  timestamps: true
});

// ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ index Ø¹Ù„Ù‰ Ø§Ù„Ø«Ù„Ø§Ø« Ø­Ù‚ÙˆÙ„ Ø¹Ø´Ø§Ù† ØªØ³Ø±ÙŠØ¹ Ø§Ù„Ø¨Ø­Ø«
repProductStockSchema.index({ companyId: 1, repId: 1, productId: 1 }, { unique: true });

module.exports = model('RepProductStock', repProductStockSchema);
 RepStockHistory.js const { Schema, model, Types } = require('mongoose');

const repStockHistorySchema = new Schema({
  companyId: {
    type: Types.ObjectId,
    ref: 'Company',
    required: true
  },
  repId: {
    type: Types.ObjectId,
    ref: 'User',
    required: true
  },
  productId: {
    type: Types.ObjectId,
    ref: 'Product',
    required: true
  },
  quantityChange: {
    type: Number,
    required: true,
  },
  reason: {
    type: String,
    default: '',
    trim: true
  },
  addedBy: {
    type: Types.ObjectId,
    ref: 'User',
    required: true
  },
  includeInAnalysis: {
    type: Boolean,
    default: false
  }
}, {
  timestamps: true
});

// index Ù„ØªØ­Ø³ÙŠÙ† Ø£Ø¯Ø§Ø¡ Ø§Ù„ÙÙ„ØªØ±Ø© ÙˆØ§Ù„ØªØ¬Ù…ÙŠØ¹
repStockHistorySchema.index({ companyId: 1, repId: 1, productId: 1, createdAt: -1 });

module.exports = model('RepStockHistory', repStockHistorySchema);
 Sample.js const { Schema, model, Types } = require('mongoose');

const sampleSchema = new Schema({
  companyId: {
    type: Types.ObjectId,
    ref: 'Company',
    required: true
  },
  takenBy: {
    type: Types.ObjectId,
    ref: 'User',
    required: true
  },
  productId: {
    type: Types.ObjectId,
    ref: 'Product',
    required: true
  },
  quantity: {
    type: Number,
    required: true,
    min: 1
  },
  type: {
    type: String,
    enum: ['customer', 'personal'],
    required: true
  },
  customerId: {
    type: Types.ObjectId,
    ref: 'Customer'
  },
  reportId: {
    type: Types.ObjectId,
    ref: 'DailyReport'
  },
  visitId: {
    type: Types.ObjectId,
    ref: 'Visit'
  },
  notes: {
    type: String,
    default: ''
  }
}, {
  timestamps: true
});

sampleSchema.index({ companyId: 1, takenBy: 1, productId: 1, createdAt: -1 });

module.exports = model('Sample', sampleSchema);
